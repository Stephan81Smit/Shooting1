<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Telescope Hunter - Final Working Edition</title>
    <!-- Using the latest stable Kaboom.js version -->
    <script src="https://unpkg.com/kaboom@3000/dist/kaboom.js"></script>
    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; background: #000; }
        canvas { display: block; max-width: 100vw; max-height: 100vh; cursor: crosshair; }
    </style>
</head>
<body>
    <script>
        // Initialize Kaboom
        kaboom({
            width: 1024,
            height: 768,
            letterbox: true,
            background: [10, 15, 30], // Deep space blue
        });

        // --- GAME CONFIGURATION ---
        const WORLD_SIZE = 4000; // The world is larger than the screen
        const MIN_ZOOM = 0.5;
        const MAX_ZOOM = 3.0;

        // --- SCENE: GAME ---
        scene("game", () => {
            let score = 0;
            let ammo = 8;
            let reloading = false;
            let currentZoom = 1;

            // --- WORLD SETUP ---
            // Procedurally generate a starry background that fills the vast world
            for (let i = 0; i < 200; i++) {
                add([
                    circle(rand(1, 3)),
                    pos(rand(-WORLD_SIZE, WORLD_SIZE), rand(-WORLD_SIZE, WORLD_SIZE)),
                    color(255, 255, 255, rand(0.5, 1)),
                ]);
            }
            
            // --- TELESCOPE VIEW & UI ---
            // This component uses custom drawing to create the scope vignette effect
            add([
                fixed(), // Stays on screen
                z(100),    // Appears on top of the game world
                {
                    // The draw() function runs every frame for this object
                    draw() {
                        const scopeRadius = width() / 3;
                        // Four black rectangles create the mask outside the scope
                        drawRect({ width: width(), height: height() / 2 - scopeRadius, pos: vec2(0, 0), color: BLACK });
                        drawRect({ width: width(), height: height() / 2 - scopeRadius, pos: vec2(0, height() / 2 + scopeRadius), color: BLACK });
                        drawRect({ width: width() / 2 - scopeRadius, height: height(), pos: vec2(0, 0), color: BLACK });
                        drawRect({ width: width() / 2 - scopeRadius, height: height(), pos: vec2(width() / 2 + scopeRadius, 0), color: BLACK });
                        // Draw the scope's border
                        drawCircle({ pos: center(), radius: scopeRadius, outline: { color: WHITE, width: 2 }, fill: false });
                    },
                },
            ]);

            // Create a detailed crosshair that is always centered
            function drawCrosshair() {
                const centerPos = center();
                const lineLength = 25;
                const gap = 3;
                drawLine({ p1: centerPos.sub(lineLength, 0), p2: centerPos.sub(gap, 0), color: RED, width: 1 });
                drawLine({ p1: centerPos.add(lineLength, 0), p2: centerPos.add(gap, 0), color: RED, width: 1 });
                drawLine({ p1: centerPos.sub(0, lineLength), p2: centerPos.sub(0, gap), color: RED, width: 1 });
                drawLine({ p1: centerPos.add(0, lineLength), p2: centerPos.add(0, gap), color: RED, width: 1 });
            }
            add([ fixed(), z(101), { draw: drawCrosshair } ]);

            // HUD Elements
            const scoreUI = add([ text("Score: 0"), pos(20, 20), fixed(), z(110) ]);
            const ammoUI = add([ text("Ammo: 8"), pos(width() - 20, 20), anchor("topright"), fixed(), z(110) ]);

            // --- CAMERA & CONTROLS ---
            // Camera smoothly follows the mouse cursor
            onUpdate(() => {
                // lerp() creates a smooth "lag" effect for the camera
                const targetCamPos = camPos().lerp(mousePos(), dt() * 2);
                // Clamp camera position to stay within the world bounds
                camPos(
                    clamp(targetCamPos.x, -WORLD_SIZE, WORLD_SIZE),
                    clamp(targetCamPos.y, -WORLD_SIZE, WORLD_SIZE)
                );
            });

            // Zoom functionality using a standard browser event listener for stability
            canvas.addEventListener("wheel", (e) => {
                e.preventDefault(); // Stop the page from scrolling
                currentZoom -= e.deltaY * 0.001;
                currentZoom = clamp(currentZoom, MIN_ZOOM, MAX_ZOOM);
                camScale(currentZoom);
            });

            // --- TARGET & GAMEPLAY SYSTEMS ---
            function spawnTarget() {
                const spawnAngle = rand(0, 360);
                const spawnDist = rand(800, WORLD_SIZE * 0.9);
                // Spawn target relative to the current camera position
                const spawnPos = camPos().add(Vec2.fromAngle(spawnAngle).scale(spawnDist));
                add([ circle(30), pos(spawnPos), color(255, 80, 80), area(), outline(3, WHITE), "target" ]);
            }
            
            function shatter(p) {
                for (let i = 0; i < 10; i++) {
                    add([ rect(rand(5, 12), rand(5, 12)), pos(p), color(255, 80, 80), rotate(rand(0, 360)), lifespan(1.5), move(rand(0, 360), rand(200, 500)) ]);
                }
            }

            // Off-screen target indicator arrow
            const indicator = add([ pos(0,0), polygon([vec2(0,-10), vec2(10,10), vec2(-10,10)]), color(255,255,0), opacity(0), z(105), fixed(), "indicator" ]);
            
            onUpdate(() => {
                let closestTarget = null;
                let minDist = Infinity;
                
                // --- FIX: Replaced every() with get().forEach() for maximum stability ---
                get("target").forEach((t) => {
                    const d = t.pos.dist(camPos());
                    if (d < minDist) {
                        minDist = d;
                        closestTarget = t;
                    }
                });

                if (closestTarget) {
                    const screenPos = toScreen(closestTarget.pos);
                    const scopeRadius = width() / 3;
                    const distFromCenter = screenPos.dist(center());

                    // Only show the indicator if the target is outside the scope view
                    if (distFromCenter > scopeRadius) {
                        indicator.opacity = 1;
                        const angle = center().angle(screenPos);
                        indicator.pos = center().add(Vec2.fromAngle(angle).scale(scopeRadius - 20));
                        indicator.angle = angle + 90; // Point the arrow correctly
                    } else {
                        indicator.opacity = 0;
                    }
                } else {
                    indicator.opacity = 0; // No targets, no indicator
                }
            });

            // Shooting logic
            onMousePress(() => {
                if (reloading || ammo <= 0) return;
                ammo--;
                // The shot is always at the center of the camera's view
                const shotPos = camPos();
                // Correctly scale the target's hitbox based on the current zoom level
                const hit = get("target").find(t => t.pos.dist(shotPos) < 30 / currentZoom);
                if (hit) {
                    shatter(hit.pos);
                    destroy(hit);
                    score += 100;
                    // Spawn a new target to replace the one destroyed
                    wait(1, spawnTarget);
                }
                if (ammo <= 0) {
                    reloading = true;
                    wait(2, () => { ammo = 8; reloading = false; });
                }
            });

            // Keep HUD text updated
            onUpdate(() => {
                scoreUI.text = `Score: ${score}`;
                ammoUI.text = reloading ? "Reloading..." : `Ammo: ${ammo}`;
            });

            // Spawn the initial wave of targets
            for (let i=0; i < 5; i++) {
                spawnTarget();
            }
        });

        // Start the game
        go("game");
    </script>
</body>
</html>
