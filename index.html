<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Telescope Hunter - Corrected Edition</title>
    <script src="https://unpkg.com/kaboom@3000/dist/kaboom.js"></script>
    <style>
        body, html { margin: 0; padding: 0; overflow: hidden; background: #000; }
        canvas { display: block; max-width: 100vw; max-height: 100vh; }
    </style>
</head>
<body>
    <script>
        // Initialize Kaboom
        kaboom({
            width: 1024,
            height: 768,
            letterbox: true,
            background: [10, 15, 30], // Deep space blue
        });

        // --- GAME CONFIGURATION ---
        const WORLD_SIZE = 4000;
        const MIN_ZOOM = 0.5;
        const MAX_ZOOM = 3;

        // --- SCENE: GAME ---
        scene("game", () => {
            let score = 0;
            let ammo = 8;
            let reloading = false;
            let currentZoom = 1;

            // --- WORLD SETUP ---
            for (let i = 0; i < 200; i++) {
                add([
                    circle(rand(1, 3)),
                    pos(rand(-WORLD_SIZE, WORLD_SIZE), rand(-WORLD_SIZE, WORLD_SIZE)),
                    color(255, 255, 255, rand(0.5, 1)),
                ]);
            }
            
            // --- TELESCOPE VIEW & UI ---
            add([
                fixed(),
                z(100),
                {
                    draw() {
                        const scopeRadius = width() / 3;
                        // Four rectangles to create the black bars (vignette)
                        drawRect({ width: width(), height: height() / 2 - scopeRadius, pos: vec2(0, 0), color: BLACK });
                        drawRect({ width: width(), height: height() / 2 - scopeRadius, pos: vec2(0, height() / 2 + scopeRadius), color: BLACK });
                        drawRect({ width: width() / 2 - scopeRadius, height: height(), pos: vec2(0, 0), color: BLACK });
                        drawRect({ width: width() / 2 - scopeRadius, height: height(), pos: vec2(width() / 2 + scopeRadius, 0), color: BLACK });
                        drawCircle({ pos: center(), radius: scopeRadius, outline: { color: WHITE, width: 2 }, fill: false });
                    },
                },
            ]);

            function drawCrosshair() {
                const centerPos = center();
                const lineLength = 25;
                const gap = 3;
                drawLine({ p1: centerPos.sub(lineLength, 0), p2: centerPos.sub(gap, 0), color: RED, width: 1 });
                drawLine({ p1: centerPos.add(lineLength, 0), p2: centerPos.add(gap, 0), color: RED, width: 1 });
                drawLine({ p1: centerPos.sub(0, lineLength), p2: centerPos.sub(0, gap), color: RED, width: 1 });
                drawLine({ p1: centerPos.add(0, lineLength), p2: centerPos.add(0, gap), color: RED, width: 1 });
            }
            add([ fixed(), z(101), { draw: drawCrosshair } ]);

            const scoreUI = add([ text("Score: 0"), pos(20, 20), fixed(), z(110) ]);
            const ammoUI = add([ text("Ammo: 8"), pos(width() - 20, 20), anchor("topright"), fixed(), z(110) ]);

            // --- CAMERA & CONTROLS ---
            onUpdate(() => {
                const targetCamPos = camPos().lerp(mousePos(), dt() * 2);
                camPos(
                    clamp(targetCamPos.x, -WORLD_SIZE, WORLD_SIZE),
                    clamp(targetCamPos.y, -WORLD_SIZE, WORLD_SIZE)
                );
            });

            // ===================================
            // == CORRECTED ZOOM FUNCTIONALITY  ==
            // ===================================
            // The 'wheel' event is a native browser event, not a Kaboom function[2][5].
            // We attach it directly to the game's canvas element provided by Kaboom.
            canvas.addEventListener("wheel", (e) => {
                // Prevent the browser page from scrolling
                e.preventDefault();
                
                // Adjust zoom based on scroll direction
                currentZoom -= e.deltaY * 0.001;
                currentZoom = clamp(currentZoom, MIN_ZOOM, MAX_ZOOM);
                camScale(currentZoom);
            });
            // ===================================
            // ==       END OF FIX              ==
            // ===================================


            // --- TARGET & GAMEPLAY SYSTEMS ---
            function spawnTarget() {
                const spawnAngle = rand(0, 360);
                const spawnDist = rand(800, WORLD_SIZE * 0.9);
                const spawnPos = camPos().add(Vec2.fromAngle(spawnAngle).scale(spawnDist));
                add([ circle(30), pos(spawnPos), color(255, 80, 80), area(), outline(3, WHITE), "target" ]);
            }
            
            function shatter(p) {
                for (let i = 0; i < 10; i++) {
                    add([ rect(rand(5, 12), rand(5, 12)), pos(p), color(255, 80, 80), rotate(rand(0, 360)), lifespan(1.5), move(rand(0, 360), rand(200, 500)) ]);
                }
            }

            const indicator = add([ pos(0,0), polygon([vec2(0,-10), vec2(10,10), vec2(-10,10)]), color(255,255,0), opacity(0), z(105), fixed(), "indicator" ]);
            onUpdate(() => {
                let closestTarget = null;
                let minDist = Infinity;
                
                every("target", (t) => {
                    const d = t.pos.dist(camPos());
                    if (d < minDist) { minDist = d; closestTarget = t; }
                });

                if (closestTarget) {
                    const screenPos = toScreen(closestTarget.pos);
                    const scopeRadius = width() / 3;
                    const distFromCenter = screenPos.dist(center());

                    if (distFromCenter > scopeRadius) {
                        indicator.opacity = 1;
                        const angle = center().angle(screenPos);
                        indicator.pos = center().add(Vec2.fromAngle(angle).scale(scopeRadius - 20));
                        indicator.angle = angle + 90;
                    } else {
                        indicator.opacity = 0;
                    }
                } else {
                    indicator.opacity = 0;
                }
            });

            onMousePress(() => {
                if (reloading || ammo <= 0) return;
                ammo--;
                const shotPos = camPos();
                const hit = get("target").find(t => t.pos.dist(shotPos) < 30 / currentZoom);
                if (hit) {
                    shatter(hit.pos);
                    destroy(hit);
                    score += 100;
                    wait(1, spawnTarget);
                }
                if (ammo <= 0) {
                    reloading = true;
                    wait(2, () => { ammo = 8; reloading = false; });
                }
            });

            onUpdate(() => {
                scoreUI.text = `Score: ${score}`;
                ammoUI.text = reloading ? "Reloading..." : `Ammo: ${ammo}`;
            });

            for (let i=0; i < 5; i++) {
                spawnTarget();
            }
        });

        go("game");
    </script>
</body>
</html>
